# frozen_string_literal: true

class SecurityVulnerabilityUpdateJob < ApplicationJob
  queue_as :vulnerability_update

  sidekiq_options retry: 2, dead: false

  # Run update for local copy of Github security advisory database
  #
  # @return [void]
  def perform
    set_execution_context("vulnerability-db-update")

    log(:info, "Running local security vulnerability database update")
    Github::Vulnerabilities::Fetcher::PACKAGE_ECOSYSTEMS.each_key do |package_ecosystem|
      log(:info, "Updating local advisory database for #{package_ecosystem}")
      vulnerabilities = Github::Vulnerabilities::Fetcher.call(package_ecosystem) do |nodes|
        update_vulnerabilities(nodes, package_ecosystem)
      rescue StandardError => e
        log_error(e)
      end
      log(:info, "  saved information for #{vulnerabilities.size} security vulnerabilities")
    end
  ensure
    clear_execution_context
  end

  private

  # Update or save vulnerabilities
  #
  # @param [Array] nodes
  # @param [String] package_ecosystem
  # @return [void]
  def update_vulnerabilities(nodes, package_ecosystem)
    nodes.each do |node|
      advisory = node.advisory

      vulnerability = Vulnerability.find_or_initialize_by(
        id: advisory.database_id,
        identifiers: advisory.identifiers.map(&:value),
        package: node.package.name,
        package_ecosystem: package_ecosystem,
        vulnerable_version_range: node.vulnerable_version_range
      )

      vulnerability.update_attributes!(
        severity: node.severity,
        summary: advisory.summary,
        description: advisory.description,
        permalink: advisory.permalink,
        origin: advisory.origin,
        references: advisory.references.map(&:url),
        first_patched_version: node.first_patched_version&.identifier,
        published_at: advisory.published_at,
        withdrawn_at: advisory.withdrawn_at
      )
    end
  end
end
